<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Modifying a Collection | Unify Framework </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Modifying a Collection | Unify Framework ">
    <meta name="generator" content="docfx 2.56.2.0">
    
    <link rel="shortcut icon" href="../../../images/favicon.ico">
    <link rel="stylesheet" href="../../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../../styles/docfx.css">
    <link rel="stylesheet" href="../../../styles/main.css">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
    <meta property="docfx:navrel" content="../../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    
    
  </head>  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../../index.html">
                <img id="logo" class="svg" src="../../../images/unify_48x48.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-12">
            <article class="content wrap" id="_content" data-uid="ModifyingACollection">
<h1 id="modifying-a-collection">Modifying a Collection</h1>

<p><sup><font color="grey">Namespace: Unify.Collections, Unify.Collections.Generic</font></sup><br>
<sup><font color="grey">Assembly: Unify.Collections.dll</font></sup></p>
<p>Unify Enumerators allow the underlying collection to be modified while iterating; items can be added, inserted or removed during the iteration process and Unify will adjust the enumerator on-the-fly.</p>
<p>To use this functionality the underlying collection <strong>must</strong> implement either of Unify's <a class="xref" href="../../api/Unify.Collections.Generic.IUnifyObservableCollection-1.html"><strong>IUnifyObservableCollection&lt;T&gt;</strong></a> or <a class="xref" href="../../api/Unify.Collections.IUnifyObservableCollection.html"><strong>IUnifyObservableCollection</strong></a> interface types; the <a class="xref" href="../../api/Unify.Collections.Generic.UnifyList-1.html"><strong>UnifyList&lt;T&gt;</strong></a> class implements both of these interfaces.</p>
<p>Unify will use the following rules when the underlying collection is modified during iteration:</p>
<ul>
<li>If an item is inserted before the current item position; the pointer will move to the right to maintain the current item position</li>
<li>If an item is removed before the current item position; the pointer will move to the left to maintain the current item position</li>
<li>If an item is inserted or removed after the current item position; the pointer remains unchanged</li>
</ul>
<p>The following animation shows how Unify Enumerators adjust their position as the underlying collection is modified.</p>
<p><img src="../../../images/enumerableRangeModify_anim.gif" alt="Enumerable Range Animation"></p>
<h2 id="example-one">Example One</h2>
<p>This example demonstrates how Unify Enumerators behave as items are added/inserted and removed from the underlying collection. An <a class="xref" href="../../api/Unify.Collections.Generic.IUnifyList-1.html"><strong>IUnifyList&lt;string&gt;</strong></a> type, containing the numbers 0-9 as words; <strong>&quot;zero&quot;</strong>, <strong>&quot;one&quot;</strong>, <strong>&quot;two&quot;</strong>, <strong>&quot;three&quot;</strong>, <strong>&quot;four&quot;</strong>, <strong>&quot;five&quot;</strong>, <strong>&quot;six&quot;</strong>, <strong>&quot;seven&quot;</strong>, <strong>&quot;eight&quot;</strong> and <strong>&quot;nine&quot;</strong>, is used as the source collection for a <a href="xref:Unify.Collections.Generic.UnifyForwardsEnumerator%601"><strong>UnifyForwardsEnumerator&lt;T&gt;</strong></a>, with a generic type <strong>T</strong> of string. It allows the Unify Enumerator to be controlled atomically, while observing the internal state at each operation. Error checking has been omitted to demonstrate exceptions, as described <a href="#exceptions"><strong>below</strong></a>.</p>
<p>Attach the script below to a GameObject and press:</p>
<ul>
<li><strong>C</strong> to Print the <a href="xref:Unify.Collections.UnifyEnumerator.Current"><strong>Current</strong></a> item</li>
<li><strong>M</strong> to Call <a href="xref:Unify.Collections.UnifyEnumerator.MoveNext"><strong>MoveNext()</strong></a></li>
<li><strong>P</strong> to Print the List - the <a href="xref:Unify.Collections.UnifyEnumerator.Current"><strong>Current</strong></a> item is shown in square brackets and uppercase, e.g. [ZERO]</li>
<li><strong>T</strong> to Toggle the value of the <a class="xref" href="../../api/Unify.Collections.UnifyEnumeratorInvalidatedAction.html"><strong>UnifyEnumeratorInvalidatedAction</strong></a> between <strong>MoveNext</strong> and <strong>DoNothing</strong></li>
<li><strong>X</strong> to Reset the Enumerator</li>
<li><strong>A</strong>+<strong>0-9</strong> to Add that number as a word to the collection, e.g. holding <strong>A</strong> and pressing <strong>4</strong> will add <strong>&quot;FOUR&quot;</strong> to the collection</li>
<li><strong>R</strong>+<strong>0-9</strong> to Remove that number from the collection, e.g. holding <strong>R</strong> and pressing <strong>2</strong> will remove <strong>&quot;TWO&quot;</strong> from the collection</li>
</ul>
<pre><code>using System;
using System.Text;
using Unify.Collections;
using Unify.Collections.Generic;
using UnityEngine;

public class Enumerators_ModifyingACollection : MonoBehaviour
{
    private int[] keyCodes = { 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265 };
    private string[] numbers = { &quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;, &quot;nine&quot; };
    private IUnifyList&lt;string&gt; list;
    private IUnifyEnumerator&lt;string&gt; enumerator;
    private bool moveNextWhenInvalidToggle = true;

    void Awake()
    {
        list = new UnifyList&lt;string&gt;(numbers);
        enumerator = new UnifyBackwardsEnumerator&lt;string&gt;(list);

        print(&quot;press C to print Current item, M to MoveNext(), P to print list, T to toggle InvalidatedAction between MoveNext and DoNothing, X to Reset enumerator&quot;);
        print(&quot;press A+[0-9] to Add that number to the list, R+[0-9] to Remove that number from the list&quot;);
        print(Environment.NewLine);
        PrintList();
        PrintCurrent();
    }

    // Update is called once per frame
    void Update()
    {
        if (Input.GetKeyUp(KeyCode.C))
        {
            PrintCurrent();
        }

        if (Input.GetKeyUp(KeyCode.M))
        {
            print(&quot;--- Move Next ---&quot;);
            enumerator.MoveNext();
            PrintList();
        }

        if (Input.GetKeyUp(KeyCode.P))
        {
            PrintList();
        }

        if (Input.GetKey(KeyCode.R))
        {
            int numberPressed = GetNumericKeyPress();

            if (numberPressed &gt; -1)
            {
                if (list.Contains(numbers[numberPressed]))
                {
                    print($&quot;--- Removing '{numbers[numberPressed]}' from list ---&quot;);
                    list.Remove(numbers[numberPressed]);
                    PrintList();
                }
                else
                {
                    print($&quot;--- Item '{numbers[numberPressed]}' is NOT in the list ---&quot;);
                }
            }
        }

        if (Input.GetKey(KeyCode.A))
        {
            int numberPressed = GetNumericKeyPress();

            if (numberPressed &gt; -1)
            {
                if (list.Contains(numbers[numberPressed]))
                {
                    print($&quot;--- The list already contains '{numbers[numberPressed]}' ---&quot;);
                }
                else
                {
                    print($&quot;--- Adding '{numbers[numberPressed]}' to the list ---&quot;);
                    list.Add(numbers[numberPressed]);
                    PrintList();
                }
            }
        }

        if (Input.GetKeyUp(KeyCode.T))
        {
            moveNextWhenInvalidToggle = !moveNextWhenInvalidToggle;
            enumerator.invalidatedAction = (moveNextWhenInvalidToggle) ? UnifyEnumeratorInvalidatedAction.MoveNext : UnifyEnumeratorInvalidatedAction.DoNothing;
            print($&quot;--- Invalidated Action = {enumerator.invalidatedAction} ---&quot;);
        }

        if (Input.GetKeyUp(KeyCode.X))
        {
            print(&quot;--- Reset ---&quot;);
            enumerator.Reset();
        }
    }

    private int GetNumericKeyPress()
    {
        for (int i = 0; i &lt; keyCodes.Length; i++)
        {
            if (Input.GetKeyUp((KeyCode)keyCodes[i]))
            {
                if (keyCodes[i] &gt;= 256)
                    return keyCodes[i] - 256;
                
                return keyCodes[i] - 48;
            }
        }

        return -1;
    }

    private void PrintCurrent()
    {
        string c = enumerator.isValid ? enumerator.Current : &quot;INVALID&quot;;
        print($&quot;Current Item: {c}&quot;);
    }

    private void PrintList()
    {
        int currentIndex = enumerator.isValid ? list.IndexOf(enumerator.Current) : -1;
        StringBuilder sb = new StringBuilder();

        for (int i = 0; i &lt; list.Count; i++)
        {
            sb.Append(currentIndex &gt; -1 &amp;&amp; currentIndex == i ? $&quot;[{list[i].ToUpper()}]&quot; : list[i]);

            if (i &lt; list.Count - 1)
                sb.Append(&quot;, &quot;);

        }

        print(sb);
    }
}
</code></pre>
<p>A special case occurs when the item the Unify Enumerator is currently positioned at is removed. In this scenario, the Unify Enumerator will rewind over previously iterated items to position itself at the last known valid item. If there are no valid items available the Unify Enumerator will enter an <strong>invalid</strong> state. The Unify Enumerator's <a href="xref:Unify.Collections.IUnifyEnumerator.invalidatedAction"><strong>invalidatedAction</strong></a> property determines what action will be taken, currently; <strong>DoNothing</strong> or <strong>MoveNext</strong>. <strong>DoNothing</strong> will keep the Unify Enumerator in an invalid state until <a href="xref:Unify.Collections.UnifyEnumerator.MoveNext"><strong>MoveNext()</strong></a> is called manually. The default value for <a href="xref:Unify.Collections.IUnifyEnumerator.invalidatedAction"><strong>invalidatedAction</strong></a> is <strong>MoveNext</strong>, which calls the <a href="xref:Unify.Collections.UnifyEnumerator.MoveNext"><strong>MoveNext()</strong></a> method to find the next valid item, if there is one. Unify Enumerator's also provide an <a href="xref:Unify.Collections.UnifyEnumerator.isValid"><strong>isValid</strong></a> property which returns <strong>true</strong> if the enumerator is in a valid state; false otherwise.</p>
<p>The number of items a Unify Enumerator will rewind over to find the previously valid item is defined by the <a href="xref:Unify.Collections.IUnifyEnumerator.maxRewindItems"><strong>maxRewindItems</strong></a> property. This value must be greater than or equal to <strong>1</strong>, the default value for this property is <strong>32</strong>.</p>
<h2 id="example-two">Example Two</h2>
<p>This example demonstrates the behviour of Unify Enumerators when the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerator-1.current?view=net-5.0" target="_blank"><strong>Current</strong></a> item is removed. Again, an <a class="xref" href="../../api/Unify.Collections.Generic.IUnifyList-1.html"><strong>IUnifyList&lt;string&gt;</strong></a> type, containing the numbers 0-9 as words; <strong>&quot;zero&quot;</strong>, <strong>&quot;one&quot;</strong>, <strong>&quot;two&quot;</strong>, <strong>&quot;three&quot;</strong>, <strong>&quot;four&quot;</strong>, <strong>&quot;five&quot;</strong>, <strong>&quot;six&quot;</strong>, <strong>&quot;seven&quot;</strong>, <strong>&quot;eight&quot;</strong> and <strong>&quot;nine&quot;</strong> is used as the source collection for a <a href="xref:Unify.Collections.Generic.UnifyForwardsEnumerator%601"><strong>UnifyForwardsEnumerator&lt;T&gt;</strong></a>, with a generic type <strong>T</strong> of string. It allows the Unify Enumerator to be controlled atomically, while observing the internal state at each operation. Error checking has been omitted to demonstrate exceptions, as described <a href="#exceptions"><strong>below</strong></a>.</p>
<p>Attach the script below to a GameObject and press:</p>
<ul>
<li><strong>C</strong> to Print the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerator-1.current?view=net-5.0" target="_blank"><strong>Current</strong></a> item</li>
<li><strong>M</strong> to Call <a href="xref:Unify.Collections.UnifyEnumerator.MoveNext"><strong>MoveNext()</strong></a></li>
<li><strong>P</strong> to Print the List - the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerator-1.current?view=net-5.0" target="_blank"><strong>Current</strong></a> item is shown in square brackets and uppercase, e.g. [ZERO]</li>
<li><strong>R</strong> to Remove the <a href="xref:Unify.Collections.UnifyEnumerator.Current"><strong>Current</strong></a> item</li>
<li><strong>T</strong> to Toggle the value of the <a class="xref" href="../../api/Unify.Collections.UnifyEnumeratorInvalidatedAction.html"><strong>UnifyEnumeratorInvalidatedAction</strong></a> between <strong>MoveNext</strong> and <strong>DoNothing</strong></li>
<li><strong>X</strong> to Reset the Enumerator</li>
</ul>
<pre><code>using System;
using System.Text;
using Unify.Collections;
using Unify.Collections.Generic;
using UnityEngine;

public class Enumerators_ModifyingACollection_Two : MonoBehaviour
{
    private IUnifyList&lt;string&gt; list = new UnifyList&lt;string&gt; { &quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;, &quot;nine&quot; };
    private IUnifyEnumerator&lt;string&gt; enumerator;

    void Awake()
    {
        enumerator = list.GetEnumerator();

        print(&quot;press P to Print list, C to Print Current item, R to Remove Current item, T to toggle InvalidatedAction between MoveNext and DoNothing, X to Reset enumerator&quot;);
        print(Environment.NewLine);
        PrintList();
        PrintCurrent();
    }

    void Update()
    {
        if (Input.GetKeyUp(KeyCode.C))
        {
            PrintCurrent();
        }

        if (Input.GetKeyUp(KeyCode.M))
        {
            print(&quot;--- Move Next ---&quot;);
            enumerator.MoveNext();

            PrintList();

            if (!enumerator.isValid)
            {
                PrintCurrent();
            }
        }

        if (Input.GetKeyUp(KeyCode.P))
        {
            PrintList();
        }

        if (Input.GetKeyUp(KeyCode.R))
        {
            if (!enumerator.isValid)
            {
                print(&quot;--- Cannot remove current item - Enumerator is in an invalid state.&quot;);
                return;
            }

            print(&quot;--- Remove Current item ---&quot;);

            string _current = enumerator.Current;
            list.Remove(enumerator.Current);

            StringBuilder _status = new StringBuilder($&quot;Removing item '{_current}' - &quot;);
          
            if (enumerator.isValid &amp;&amp; enumerator.invalidatedAction == UnifyEnumeratorInvalidatedAction.MoveNext)
            {
                _status.Append($&quot;Moving to next item '{enumerator.Current}'&quot;);
            }
            else
            {
                _status.Append(&quot;Enumerator is INVALID&quot;);
            }

            print(_status);
            PrintList();
            PrintCurrent();
            print(Environment.NewLine);
        }

        if (Input.GetKeyUp(KeyCode.T))
        {
            enumerator.invalidatedAction = (enumerator.invalidatedAction == UnifyEnumeratorInvalidatedAction.DoNothing) ? UnifyEnumeratorInvalidatedAction.MoveNext : UnifyEnumeratorInvalidatedAction.DoNothing;
            print($&quot;--- Invalidated Action = {enumerator.invalidatedAction} ---&quot;);
        }

        if (Input.GetKeyUp(KeyCode.X))
        {
            print(&quot;--- Reset ---&quot;);
            enumerator.Reset();
        }
    }

    private void PrintCurrent()
    {
        string current = enumerator.isValid ? enumerator.Current : &quot;INVALID&quot;;
        print($&quot;Current Item: [{current.ToUpper()}]&quot;);
    }

    private void PrintList()
    {
        int currentIndex = enumerator.isValid ? list.IndexOf(enumerator.Current) : -1;
        StringBuilder sb = new StringBuilder();

        for (int i = 0; i &lt; list.Count; i++)
        {
            sb.Append(currentIndex &gt; -1 &amp;&amp; currentIndex == i ? $&quot;[{list[i].ToUpper()}]&quot; : list[i]);

            if (i &lt; list.Count - 1)
            {
                sb.Append(&quot;, &quot;);
            }
        }

        print(sb);
    }
}
</code></pre>
<h2 id="exceptions">Exceptions</h2>
<p>Exceptions will <strong>always</strong> be thrown under the following circumstances:</p>
<ul>
<li>Accessing the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerator-1.current?view=net-5.0" target="_blank"><strong>Current</strong></a> item when the Unify Enumerator is in an invalid state will throw an <a href="https://docs.microsoft.com/en-us/dotnet/api/system.argumentoutofrangeexception" target="_blank"><strong>ArgumentOutOfRangeException</strong></a></li>
</ul>
</article>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            Copyright © 2020 Matt Borum
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../../styles/main.js"></script>
  </body>
</html>
